\lab{The Standard Library}{Standard Library}
\objective{Python is designed to make it easy to implement complex tasks with little code.
To that end, any Python distribution includes several built-in functions for accomplishing common tasks.
In addition, Python is designed to import and reuse Python code written by others.
A Python file that can be imported is called a module.
Any Python distribution includes a collection of modules for accomplishing a variety of tasks.
These modules are called the Python standard library.
In this lab we become familiar with the Python standard library and learn how to import and use modules.}
\label{lab:Standard Library}

\section*{Python Built-in Functions}

Every Python installation comes with several built-in functions.
A listing of all Python built-in functions can be found \href{https://docs.python.org/2/library/functions.html}{here}.
Built-in functions may be used at any time and Python will recognize them.

\begin{lstlisting}
# abs() returns the absolute value of a number
>>> abs(-5)
5

# min() returns the smallest element of a list or string
>>>min([1,2,3])
1
>>> min('xyz')
'x'

# max() returns the largest element of a list or string
>>> max([1,2,3])
3
>>> max('xyz')
'z'

# len() returns the length of a list or string
>>> len([1,2,3])
3
>>> len('abc')
3
# sum() returns the sum of a list
>>> sum([1,2,3])
6

# range(n) returns a list of numbers from 0 to n-1
>>> range(3)
[0,1,2]
\end{lstlisting}

% Problem 1: built-in methods with lists
\begin{problem}
Download \texttt{spec.py} to use as a solutions script and save it as \texttt{solutions.py}.
Write a function that accepts a list of numbers as input and returns a list with the minimum, maximum, and average of the original list (in that order).
Use floating point division to calculate the average.
\end{problem}
% TODO: in Python 3, floating point division is the default, so we can remove that last line.

\section*{Names, Namespaces, and Modules}

\subsection*{Names and Namespaces}
All objects created in Python resides in memory.
These objects may be primitive data, data structures, functions, or any other sort of Python object.
A Python \emph{name} is a reference to a Python object.

A \emph{namespace} is a dictionary that maps names to Python objects.
For example, in the following code block we create several names.

\begin{lstlisting}
# The number 13 is the object, x is the name.
>>> x = 13

# The number 4 is the object, number_of_students is the name.
>>> number_of_sudents = 4

# This is more complicated. The set of Python statements form an object.
# The name is add_numbers.
>>> def add_numbers(a, b):
...     return a + b
... 
# The list is the object, and students is the name.
>>> students = ["John", "Paul", "George", "Ringo"]
\end{lstlisting}

The equal sign assigns an object to a name.
If a name is assigned to another name, that new name refers to the same object (or a copy of it) that the orignal name refers to.
For example, if as above the name \li{students} is assigned a list of names, and then the name \li{band\_members} is assigned \li{students}, then both \li{band\_members} and \li{students} refer to the same list.

\begin{lstlisting}
>>> students = ["John", "Paul", "George", "Ringo"]
>>> band_members = students

# band_members now referes to the same object as students.
>>> band_members
['John', 'Paul', 'George', 'Ringo']
\end{lstlisting}

Python objects may be mutable or immutable.
An immutable object cannot be altered once created, so assigning a new name to it creates a copy in memory.
A mutable object's value may be changed, so assigning a new name to it does not create a copy.
For example, a list is mutable while a tuple is immutable.
% TODO: make error message all black text
\begin{lstlisting}
>>> example_tuple = (1,2)
>>> example_tuple[0] = 3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

>>> example_list = [1,2]
>>> example_list[0] = 3
>>> print(example_list)
[3,2]
\end{lstlisting}

If two names refer to the same mutable object, then any changes to the object is reflected in both names.
To avoid this, create a copy of an object.
Changes made to the copy will not change the original object.
The way to make a copy of an object varies with object types.
To make a copy of a list, use the \li{list()} built-in method.

\begin{lstlisting}
>>> students = ["John", "Paul", "George", "Pete"]
>>> band_members = students

# Replace 'Pete' with 'Ringo' in band_members
>>> band_members[3] = "Ringo"
>>> print(band_members)
['John', 'Paul', 'George', 'Ringo']

# Since 'students' and 'band_members' refer to the same object, 
# 'Ringo' also replaces 'Pete' in students
>>> print(students)
['John', 'Paul', 'George', 'Ringo']

# Make a copy this time
>>> students = ["John", "Paul", "George", "Pete"]
>>> band_members = list(students)
>>> band_members[3] = "Ringo"
>>> print(band_members)
['John', 'Paul', 'George', 'Ringo']
>>> print(students)
['John', 'Paul', 'George', 'Pete']
\end{lstlisting}

% Problem 2: which Python objects are immutable?
\begin{problem}
Python has several methods that seem to change immutable objects.
These methods actually work by making copies of objects. We can determine which object types are mutable and immutable by using the equal sign and ``changing'' the objects.
For example, if two names refer to the same list then changes to the entries of one name show up in the second.

\begin{lstlisting}
>>> list_1 = [1,2,3]
>>> list_2 = list_1
>>> list_1.append(4)
>>> print(list_1)
[1, 2, 3, 4]
>>> print(list_2)
[1, 2, 3, 4]
\end{lstlisting}

Performing a similar operation on a tuple yields a different result.
\begin{lstlisting}
>>> tuple_1 = (1,2,3)
>>> tuple_2 = tuple_1
>>> tuple_1 = tuple_1 + (4,)
>>> print(tuple_1)
(1, 2, 3, 4)
>>> print(tuple_2)
(1, 2, 3)
\end{lstlisting}

Determine which object types are mutable and which are immutable.
Use the following operations to modify each of the given types.
\begin{center}
\begin{tabular}{|c|c|}
\hline
numbers & num += 1 \\
\hline
strings & str1 += `a' \\
\hline
lists & list1.append(1) \\
\hline
tuples & tup1 += (1,) \\
\hline
dictionaries & dic1[1] = `a' \\
\hline
\end{tabular}
\end{center}

Finally, print a statement of your conclusions to the terminal with the built-in \li{print} function.
\end{problem}

\begin{info}
Many programming languages distinguish between \emph{variables} and \emph{pointers}.
A pointer typically holds a memory location where the value of some other variable is stored.
Pointer arithmetic and manipulation is delicate, occasionaly very useful, but often cumbersome.

Python names are essentially pointers, but typical pointer operations are done automatically, and objects in memory that have nothing pointing to them are automatically deleted.
Understanding how Python handles memory access via names is important for implementing reference-based data structures, such as linked lists and trees.
\end{info}

\subsection*{Modules}

In general, a module is a file that contains Python code.
The \li{import} statement loads the code from a specified Python file.
In scripts and modules, all \li{import} statements should occur at the top of the file.

The \li{import} statement first tries to find the Python file specified.
Once found, every statement in the Python file is executed.
Once imported, a module's names are available to the user.

For example, download the file \texttt{example\_module.py} and save it to a directory.
In a Python interpreter, navigate to a directory where the file is not saved.
If the interpreter then tries to \li{import example\_module}, it throws an error:

\begin{lstlisting}
>>> import example_module
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ImportError: No module named example_module
\end{lstlisting}
% TODO: black out the error message

If the interpreter is running in a directory that contains the module, no error is thrown and the module's names become available:

\begin{lstlisting}
>>> import example_module
>>> example_module.add_numbers(1,1)
2
>>> example_module.print_students()
John
Paul
George
Ringo
>>> example_module.students
['John', 'Paul', 'George', 'Ringo']
\end{lstlisting}

If the module is changed after it is imported, use the \li{reload} command to access those changes.
Using the \li{import} command again will \textbf{not} change the module.

\begin{lstlisting}
# Add this function to example_module.py and save it.
def subtract_numbers(a, b):
    return a - b
\end{lstlisting}

\begin{lstlisting}
# After modifying example_module.py, try to update the module with 'import'.
>>> import example_module
>>> example_module.subtract_numbers(2,1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute 'subtract_numbers'

# Now use 'reload' instead of 'import'.
>>> reload(example_module)
>>> example_module.subtract_numbers(2,1)
1
\end{lstlisting}
% TODO: black out the error message

% Problem 3: create your own module.
\begin{problem}
Create a module called \texttt{calculator.py}.
Write a function that returns the sum of two arguments, a function that returns the product of two arguments, and a function that returns the square root of a single argument.
(Hint: read the first paragraphs of the next section).

In your \texttt{solutions.py} file, import the \li{calculator} module.
Using the functions defined in the module, write a new function that calculates the length of the hypotenuse of a right triangle given the lengths of the other two sides.
\end{problem}

\section*{Python Standard Library}

Any Python distribution includes a set of modules that are available for use.
This set of modules is called the \emph{Python standard library}.
To access a module in the standard library use the \li{import} command with the module name.

A summary of the documentation for these modules, called the \emph{docstring}, can be read using the \li{\_\_doc\_\_} name.
For example, there is a \li{math} module in the standard library that includes common mathematical functions.
\begin{lstlisting}
>>> import math
>>> print(math.__doc__)
This module is always available.  It provides access to the
mathematical functions defined by the C standard.
\end{lstlisting}
% TODO: black out the info
Functions also have docstrings.
\begin{lstlisting}
>>> print(math.cos.__doc__)
cos(x)

Return the cosine of x (measured in radians).
\end{lstlisting}

More extensive documentation is available using the \li{help} built-in function.
Many Python interpreters provide a similar function by using a question mark.
In IPython, the question mark yields:

% TODO: black this out
\begin{lstlisting}
In [0]: import math

In [1]: math?
Type:        module
String form: <module 'math' from '/Users/ACME/anaconda/lib/python2.7/lib-dynload/math.so'>
File:        /Users/ACME/anaconda/lib/python2.7/lib-dynload/math.so
Docstring:
This module is always available.  It provides access to the
mathematical functions defined by the C standard.
\end{lstlisting}

Many interpreters also provide shortcuts for exploring modules.
In IPython if the tab button is pressed after a module name followed by a period, the available functions are displayed.

% TODO: black out this too
\begin{lstlisting}
In [1]: import math

# typing math. and then pressing tab gives the available functions.
In [2]: math.
math.acos       math.atanh      math.e          math.factorial  
math.hypot      math.log10      math.sin        math.acosh      
math.ceil       math.erf        math.floor      math.isinf      
math.log1p      math.sinh       math.asin       math.copysign   
math.erfc       math.fmod       math.isnan      math.modf       
math.sqrt       math.asinh      math.cos        math.exp        
math.frexp      math.ldexp      math.pi         math.tan        
math.atan       math.cosh       math.expm1      math.fsum       
math.lgamma     math.pow        math.tanh       math.atan2      
math.degrees    math.fabs       math.gamma      math.log        
math.radians    math.trunc


In [2]: math.sqrt?
Type:        builtin_function_or_method
String form: <built-in function sqrt>
Docstring:
sqrt(x)

Return the square root of x.
\end{lstlisting}

\subsection*{The \li{sys} module}

The \li{sys} (system) module includes methods for interacting with the Python interpreter.
The module has a name \li{argv} that is a list of arguments passed to the interpreter when it runs Python scripts.

\begin{lstlisting}
# Call this file test_script.py
import sys

print(sys.argv)
\end{lstlisting}

If this script is run from the command line with additional arguments it will print them out.

\begin{lstlisting}
$ python test_script.py I am the walrus
['test_script', 'I', 'am', 'the', 'walrus']
\end{lstlisting}

Note that command line arguments are parsed as strings.
This method can be used to point a Python script to a file to be analyzed.
It can also be used to control a script's behavior, as in the following example.

\begin{lstlisting}
# Call this file test_script2.py
import sys

if len(sys.argv) < 3:
    print("Three arguments are required")
    sys.exit(1)             # Manually quit the program early.

arg = sys.argv[2]

if sys.argv[1] == '1':
    print("-".join(arg))

elif sys.argv[1] == '2':
    print(arg.upper())
\end{lstlisting}

Now provide command line arguments to specify the behavior of the script.

\begin{lstlisting}
$ python test_script2.py 1
Three arguments are required

$ python test_script2.py 1 first
f-i-r-s-t

$ python test_script2.py 2 second
SECOND
\end{lstlisting}

\subsection*{The \li{time} module}

The \li{time} module includes functions for dealing with time.
In particular, functions in \li{time} access the computer's system clock.
This is useful for precisely measuring how long it takes for code to run.

The \li{time} module includes a function also called \li{time} that measures the number of seconds from a fixed starting point, the ``Epoch''.
For most machines, this starting point will be January 1, 1970.

\begin{lstlisting}
>>> import time

# time.time() returns the number of seconds from January 1, 1970 to the
# time of execution. This command gives a new time every time it is run.
>>> time.time()
1436832057.321525
\end{lstlisting}

In order to measure how long it takes to execute some Python code, a measurement is taken right before and right after it is run.
Subtracting the first measurement from the second gives the amount of time in seconds that have passed.

\begin{lstlisting}
def time_for_loop():
    # Time how long it takes to go through 10000 iterations using 'range'.
    start = time.time()             # Clock the starting time.
    for i in range(10000): pass     # Perform the operation.
    end = time.time()               # Clock the ending time.
    return end - start              # Report the difference.
\end{lstlisting}

The standard library also has a module called \li{timeit}.
This library is built to time Python code and has more tools than 
\li{time}.
In IPython, \li{timeit} can be used like a built-in function any time with the \li{\%timeit} command.

\begin{lstlisting}
# Time how long it takes to go through 10000 iterations using 'xrange'.
In [0]: %timeit for i in xrange(10000): pass 
1000 loops, best of 3: 303 Âµs per loop
\end{lstlisting}

% Problem 4: running a file from the command line and timing code segments
\begin{problem}
Download the files \texttt{matrix\_multiply.py} and \texttt{matrices.npz}.
The Python file \li{matrix\_multiply.py} is a module that has three methods for multiplying two matrices together, called \li{method1}, \li{method2}, and \li{method3}.
It also has a \li{load\_matrices} method that returns two matrices from \li{matrices.npz}.

Write a function that will do the following:
\begin{enumerate}
\item If no command line argument is given, print ``No Input."
\item If anything other than ``matrices.npz'' is given, print ``Incorrect Input."
\item If ``matrices.npz'' is given as a command line argument, load two matrices from \texttt{matrices.npz}. Time (separately) how long each method takes to multiply the two matrices together, then print the results to the terminal.
\end{enumerate}
\end{problem}
