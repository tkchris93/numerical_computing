\lab{The Standard Library}{The Python Standard Library}
\label{lab:Standard Library}
\objective{Python is designed to make it easy to implement complex tasks with little code.
To that end, every Python distribution includes several built-in functions for accomplishing common tasks.
In addition, Python is designed to import and reuse code written by others.
A Python file with code that can be imported is called a \emph{module}.
All Python distributions include a collection of modules for accomplishing a variety of tasks, collectively called the \emph{Python Standard Library}.
In this lab we explore some built-in functions, learn how to create, import, and use modules, and become familiar with the standard library.}

% Suggestions for improvement:
%   - More problems.

\section*{Built-in Functions} % ===============================================

Every Python installation comes with several built-in functions that may be used at any time.
IPython's object introspection feature makes it easy to learn about these functions.
Start IPython from the terminal and use \li{?} to bring up technical details on each function.

\begin{lstlisting}
In [1]: min?
Docstring:
<<min(iterable[, key=func]) -> value
min(a, b, c, ...[, key=func]) -> value

With a single iterable argument, return its smallest item.
With two or more arguments, return the smallest argument.>>
Type:      builtin_function_or_method

In [2]: len?
Docstring:
<<len(object) -> integer

Return the number of items of a sequence or collection.>>
Type:      builtin_function_or_method
\end{lstlisting}

\begin{table}[H]
\begin{tabular}{r|l}
Function & Returns \\ \hline
\li{abs()} & The absolute value of a real number, or the magnitude\\
& of a complex number.\\
\li{min()} & The smallest element of a single iterable, or the smallest\\
& of several arguments. Strings are compared  based on\\
& lexicographical order: numerical characters first, then\\
& upper-case letters, then lower-case letters.\\
\li{max()} & The largest element of a single iterable, or the largest\\
& of several arguments.\\
\li{len()} & The number of items of a sequence or collection.\\
\li{round()} & A float rounded to a given precision in decimal digits.\\
\li{sum()} & The sum of a sequence of numbers.\\
\end{tabular}
\caption{Some common built-in functions for numerical calculations.}
\label{table:builtin}
\end{table}

% TODO: add brackets to the print function for Python 3.
\begin{lstlisting}
# abs() can be used with real or complex numbers.
>>> print abs(-7), abs(3 + 4j)
7 5.0

# min() and max() can be used on a list, string, or several arguments.
# String characters are ordered lexicographically.
>>> print min([4, 2, 6]), min("aXbYcZ"), min(1, 'a', 'A')
2 X 1
>>> print max([4, 2, 6]), max("aXbYcZ"), max(1, 'a', 'A')
6 c a

# len() can be used on a string, list, set, dict, tuple, or other iterable.
>>> print len([2, 7, 1]), len("abcdef"), len({1, 'a', 'a'})
3 6 2

# sum() can be used on iterables containing numbers, but not strings.
>>> my_list = [1, 2, 3]
>>> my_tuple = (4, 5, 6)
>>> my_set = {7, 8, 9}
>>> sum(my_list) + sum(my_tuple) + sum(my_set)
45
>>> sum([min(my_list), max(my_tuple), len(my_set)])
10

# round() is useful for formatting data to be printed.
>>> round(3.14159265358979323, 2)
3.14
\end{lstlisting}

More detailed documentation on all of Python's built-in functions can be found at \url{https://docs.python.org/2/library/functions.html}.

\begin{problem} % Problem 1: using built-in methods with lists.
Write a function that accepts a list of numbers as input and returns a new list with the minimum, maximum, and average of the original list (in that order).
Remember to use floating point division to calculate the average.
Can you implement this function in a single line?
\end{problem}
% TODO: in Python 3, floating point division is the default, so we can remove the reminder about floating point division.

\section*{Namespaces} % =======================================================

\subsection*{Names} % ---------------------------------------------------------
All Python objects reside somewhere in computer memory.
These objects may be primitive data, data structures, functions, or any other sort of Python object.
A \emph{name} (or variable) is a reference to a Python object.
A \emph{namespace} is a dictionary that maps names to Python objects.

\begin{lstlisting}
# The number 4 is the object, 'number_of_students' is the name.
>>> number_of_sudents = 4

# The list is the object, and 'students' is the name.
>>> students = ["John", "Paul", "George", "Ringo"]

# Python statements defining a function form an object.
# The name for this function is 'add_numbers'.
>>> def add_numbers(a, b):
...     return a + b
... 
\end{lstlisting}

A single equals sign assigns a name to an object.
If a name is assigned to another name, that new name refers to the same object that the original name refers to (or a copy of it).

\begin{lstlisting}
>>> students = ["John", "Paul", "George", "Ringo"]
>>> band_members = students
>>> print(band_members)
<<['John', 'Paul', 'George', 'Ringo']>>
\end{lstlisting}

To see all of the names in the current namespace, use the built-in function \li{dir()}.
To delete a variable from the namespace, use the \li{del} keyword (be careful!).

\begin{lstlisting}
>>> subjects = ["Statistics", "Technology", "Engineering", "Mathematics"]
>>> num = 4
>>> dir()
<<['__builtins__', '__doc__', '__name__', '__package__', 'num', 'subjects']>>
>>> del num
>>> dir()
<<['__builtins__', '__doc__', '__name__', '__package__', 'subjects']>>
>>> print(num)
<<Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'num' is not defined>>
\end{lstlisting}

\begin{info}
Many programming languages distinguish between \emph{variables} and \emph{pointers}.
A pointer holds a memory location where an object is stored.
% Pointer arithmetic and manipulation is delicate, occasionally very useful, but often cumbersome.
% 
Python names are essentially pointers. %but pointer operations are done automatically,
Objects in memory that have no names pointing to them are automatically deleted (this is called \emph{garbage collection}).
% Understanding how Python handles memory access via names is important for implementing reference-based data structures, such as linked lists and trees.
\end{info}

\subsection*{Mutability} % ----------------------------------------------------

Python object types are either mutable or immutable.
An \emph{immutable} object cannot be altered once created, so assigning a new name to it creates a copy in memory.
A \emph{mutable} object's value may be changed, so assigning a new name to it does \emph{not} create a copy.
Therefore, if two names refer to the same mutable object, any changes to the object will be reflected in both names.

\begin{warn} % Extensive Mutability Warning.
Mutability can be very useful in some settings, but it can also cause hard-to-find problems when a copy should have been to be made.
For example, suppose we have a dictionary mapping items to their base prices, and we want make a new dictionary that accounts for a small sales tax.

\begin{lstlisting}
>>> original = {"pencil": 1, "pen": 2, "paper": 3, "computer": 2000}
>>> tax_prices = original                   # Make a "copy" for processing.
>>> for item in tax_prices:
...     price = tax_prices[item]            # Get the original price.
...     tax_prices[item] += .07 * price     # Add on a 7% tax.
...
# Now the base prices have been updated to the total price.
>>> print(tax_prices)
<<{'pencil': 1.07, 'pen': 2.14, 'paper': 3.21, 'computer': 2140.0}>>

# However, dictionaries are mutable, so 'prices' and 'original' actually
# refer to the same object. The original base prices have now been lost.
>>> print(original)
<<{'pencil': 1.07, 'pen': 2.14, 'paper': 3.21, 'computer': 2140.0}>>
\end{lstlisting}

To avoid this problem, create a copy of an object.
Changes made to the copy will not change the original object.
In this case, we replace the $2^{nd}$ line of the above code with the following:
\begin{lstlisting}
>>> tax_prices = dict(original)
\end{lstlisting}
Then, after running the same procedure, the two dictionaries will be different.
\end{warn}

\begin{problem} % Problem 2: determine which Python types are immutable.
Python has several methods that seem to change immutable objects.
These methods actually work by making copies of objects.
We can therefore determine which object types are mutable and which are immutable by using the equal sign and ``changing'' the objects.

\begin{lstlisting}
>>> dict_1 = {1: 'x', 2: 'b'}           # Create a dictionary.
>>> dict_2 = dict_1                     # Assign it a new name.
>>> dict_2[1] = 'a'                     # Change the 'new' dictionary.
>>> dict_1 == dict_2                    # Compare the two names.
True
\end{lstlisting}

Since altering one name altered the other, we conclude that no copy has been made and that therefore Python dictionaries are mutable.
If we repeat this process with a different type and the two names are different in the end, we will know that a copy had been made and the type is immutable.

Following the example given above, determine which object types are mutable and which are immutable.
Use the following operations to modify each of the given types.

\begin{center}
\begin{tabular}{|c|c|}
\hline
numbers & num += 1 \\
\hline
strings & word += `a' \\
\hline
lists & list.append(1) \\
\hline
tuples & tuple += (1,) \\
\hline
dictionaries & dict[1] = `a' \\
\hline
\end{tabular}
\end{center}
Print a statement of your conclusions.
% TODO: Evaluate this problem. How can we make this a little clearer?
\end{problem}

\section*{Modules} % ==========================================================

In general, a Python \emph{module} is a file containing Python code that is meant to be used in some other setting, and not necessarily run directly.\footnote{A Python file that is not meant to be imported is often called a \emph{script}.}
The \li{import} statement loads the code from a specified Python file.
That is, when a module containing some functions, classes, or other objects is imported, those functions, classes, and objects are made available for use.

All import statements should occur at the top of the file, below the header but before any other code.
Thus we expand our example of typical Python file from the previous lab to the following:

\begin{lstlisting}
# filename.py
"""This is the file header.
The header contains basic information about the file.
"""

import math
import numpy as np
from scipy import linalg as la
import matplotlib.pyplot as plt

def main():
    """This is a docstring. It provides information about the function."""
    print("Hello, world!")

if __name__ == "__main__":
    main()
\end{lstlisting}

The modules imported in this example are some of the most important modules used in Python for scientific computing.
The NumPy, SciPy, and MatPlotLib modules will be presented in detail in subsequent labs.

\subsection*{Importing Syntax} % ----------------------------------------------

There are several ways to use the \li{import} statement.
\begin{enumerate}

\item \li{import <module>} makes the specified module available under the alias of its own name. For example, the \li{math} module has a function called \li{sqrt()} that computes the square root of the input.
\begin{lstlisting}
>>> import math                 # The name 'math' now gives access to
>>> math.sqrt(2)                # the built-in math module.
1.4142135623730951
\end{lstlisting}

\item \li{import <module> as <name>} creates an alias for an imported module. The alias is added to the namespace, but the module name itself is not.

\begin{lstlisting}
>>> import math as m            # The name 'm' gives access to the math
>>> m.sqrt(2)                   # module, but the name 'math' does not.
1.4142135623730951
>>> math.sqrt(2)
<<Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
NameError: name 'math' is not defined>>
\end{lstlisting}

\item \li{from <module> import <<<object>>>} loads the specified object into the namespace without loading anything else in the module or the module name itself.
This is used most often to access specific functions from a module.
The \li{as} statement can also be tacked on to create an alias.

\begin{lstlisting}
>>> from math import sqrt       # The name 'sqrt' gives access to the
>>> sqrt(2)                     # square root function, but the rest of
1.4142135623730951              # the math module is unavailable.
>>> math.sin(2)
<<Traceback (most recent call last):
  File "<stdin>", line 3, in <module>
NameError: name 'math' is not defined>>
\end{lstlisting}
\end{enumerate}

In each case, the far right word of the import statement is the name that is added to the namespace.

\subsection*{Running and Importing} % -----------------------------------------

Consider the following simple Python module, saved as \texttt{example.py}.

% TODO: put parentheses on the print statements for Python 3.
\begin{lstlisting}
data = [1, 2, 3, 4]

def display():
    print "Data:", data

if __name__ == '__main__':
    print "This file was executed from the terminal or an interpreter."
    display()
else:
    print "This file was imported."
\end{lstlisting}

Executing the file from the terminal executes the file line by line, including the code under the \li{if __name__ == '__main__'} clause.

\begin{lstlisting}
$ python example.py
<<Data: [1, 2, 3, 4]
This file was executed from the terminal or an interpreter.>>
\end{lstlisting}

Executing the file with IPython's \li{run} command executes each line and also adds the module's names to the current namespace.

\begin{lstlisting}
In [1]: run example.py
<<Data: [1, 2, 3, 4]
This file was executed from the terminal or an interpreter.>>

In [2]: display()
Data: [1, 2, 3, 4]
\end{lstlisting}

Importing the file also executes each line, but only adds the indicated alias to the namespace.
% When creating modules, beware of stray code that might be executed unintentionally when a file is imported.

\begin{lstlisting}
In [1]: import example
<<This file was imported.>>

# The module's names are not direcly available...
In [2]: display()
<<---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-2-795648993119> in <module>()
----> 1 display()

NameError: name 'display' is not defined>>

# ...unless accessed via the module name.
In [3]: example.display()
Data: [1, 2, 3, 4]
\end{lstlisting}

Note that code under the \li{if __name__ == '__main__'} clause is \emph{not} executed when a file is imported.
We will explore the \li{__name__} attribute a little more in a future lab. %(?)

% WARNING! In Python 3, reload() is no longer a built-in function
%   (you have to use importlib.reload() instead). Delete this section?
\begin{comment} % vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
\subsection*{Reloading and Testing} % -----------------------------------------

In IPython, importing provides a quick way to test code.
However, if a module has been imported and the source code then changes (you test your code, discover and error, then fix it), the \li{reload()} function must be used to access the changes.
Using the \li{import} command again will \textbf{not} change the module.

Consider this example where we test a file containing a single function.
\begin{lstlisting}
# example2.py
def sum_of_squares(x):
    """Return the sum of the squares of all integers less than or equal to x."""
    return sum([i**2 for i in range(x)])
\end{lstlisting}

In IPython, import the file and test the \li{sum_of_squares} function.
\begin{lstlisting}
In [1]: import example2 as test

In [2]: test.sum_of_squares(3)
Out[2]: 5
\end{lstlisting}

Since $1^2 + 2^2 + 3^2 = 14$, not $5$, something has gone wrong.
We modify the file to correct the mistake:

\begin{lstlisting}
# example2.py
def sum_of_squares(x):
    """Return the sum of the squares of all integers less than or equal to x."""
    return sum([i**2 for i in range(1,x+1)])    # Be sure to include x.
\end{lstlisting}

\begin{lstlisting}
# Using import again doesn't change the loaded module, even though
# the source file was modified.
In [3]: import test

In [4]: test.sum_of_squares(3)
Out[4]: 5

# Using reload, however, updates the loaded module with the changes.
In [5]: reload(test)
Out[5]: <<<module 'example2' from 'example2.py'>>>

In [6]: test.sum_of_squares(3)
Out[6]: 14
\end{lstlisting}
\end{comment} % ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\begin{problem} % Problem: create and use a simple module.
Create a module called \texttt{calculator.py}.
Write a function that returns the sum of two arguments, a function that returns the product of two arguments, and a function that returns the square root of a single argument.
When the file is either run or imported, nothing should be executed.

In your solutions file, import your new calculator module.
Using only the functions defined in the module, write a new function that calculates the length of the hypotenuse of a right triangle given the lengths of the other two sides.
\end{problem}

\section*{Python Standard Library} % ==========================================

All Python distributions include a collection of modules for accomplishing a variety of common tasks, collectively called the \emph{Python standard library}.
See Table \ref{table:stdlib}.

\begin{table}[H] % Some standard library modules.
\begin{tabular}{c|l}
Module & Description / Purpose \\ \hline
\li{csv} & Comma Separated Value (CSV) file parsing and writing.\\
\li{math} & Standard mathematical functions.\\
\li{random} & Random variable generators.\\
\li{sys} & Tools for interacting with the interpreter.\\
\li{time} & Time value generation and manipulation.\\
\li{timeit} & Measuring execution time of small code snippets.
\end{tabular}
\caption{Some common standard library modules.}
\label{table:stdlib}
\end{table}

Using IPython's object introspection, we can learn about how to use the various modules and functions in the standard library very quickly.
Use \li{?} or \li{help()} for information on the module or one of its names.
To see the entire module's namespace, use the \li{tab} key.

\begin{lstlisting}
In [1]: import math

In [2]: math?
<<Type:        module
String form: <module 'math' from '/anaconda/lib/python2.7/lib-dynload/math.so'>
File:        /anaconda/lib/python2.7/lib-dynload/math.so
Docstring:
This module is always available.  It provides access to the
mathematical functions defined by the C standard.>>

# Type the module name, a period, then press tab to see the module's namespace.
In [3]: math.   # Press 'tab'.
<<math.acos       math.atanh      math.e          math.factorial  
math.hypot      math.log10      math.sin        math.acosh      
math.ceil       math.erf        math.floor      math.isinf      
math.log1p      math.sinh       math.asin       math.copysign   
math.erfc       math.fmod       math.isnan      math.modf       
math.sqrt       math.asinh      math.cos        math.exp        
math.frexp      math.ldexp      math.pi         math.tan        
math.atan       math.cosh       math.expm1      math.fsum       
math.lgamma     math.pow        math.tanh       math.atan2      
math.degrees    math.fabs       math.gamma      math.log        
math.radians    math.trunc>>

In [4]: math.sqrt?
<<Type:        builtin_function_or_method
String form: <built-in function sqrt>
Docstring:
sqrt(x)

Return the square root of x.>>
\end{lstlisting}

\subsection*{The Sys Module} % ------------------------------------------------

The \li{sys} (system) module includes methods for interacting with the Python interpreter.
The module has a name \li{argv} that is a list of arguments passed to the interpreter when it runs a Python file.
Consider the following simple script:

\begin{lstlisting}
# echo.py
import sys

print(sys.argv)
\end{lstlisting}

If this file is run from the command line with additional arguments it will print them out.
Note that command line arguments are parsed as strings.

\begin{lstlisting}
$ python echo.py I am the walrus
['echo', 'I', 'am', 'the', 'walrus']
\end{lstlisting}

Command line arguments can be used to control a script's behavior, as in the following example:

\begin{lstlisting}
# cipher.py
import sys

if len(sys.argv) < 3:
    print("Three arguments are required")
    sys.exit(1)                     # Manually quit the program early.

arg = sys.argv[2]

if sys.argv[1] == '1':
    print("-".join(arg))

elif sys.argv[1] == '2':
    print(arg.upper())
\end{lstlisting}

Now we can specify the behavior of the script with command line arguments.

\begin{lstlisting}
$ python cipher.py 1
Three arguments are required

$ python cipher.py 1 first
f-i-r-s-t

$ python cipher.py 2 second
SECOND
\end{lstlisting}

% TODO: discuss raw_input()
% TODO: raw_input() in Python 2.7 --> input() in Python 3.0
Another way to get input from the program user is to prompt the user for text.
The built-in function \li{raw_input()} pauses the program and waits for the user to type something.
Like the entries of \li{sys.argv}, \li{raw_input()} returns a string.

\subsection*{The Random Module} % =============================================

TODO !!

% choice(), randint(), random(), sample(), seed(), shuffle() 

\begin{problem} % Problem: shut the box.
The game \emph{shut the box} is a popular British pub game that is used to help children with arithmetic.

The provided module \texttt{box.py} contains some functions that will be useful in your implementation of the game.

% Sample game session
\begin{lstlisting}
<<$ python solutions.py
Player name: Math TA

Numbers left: [1, 2, 3, 4, 5, 6, 7, 8, 9]
Roll: 7
Numbers to eliminate: 1 2 4

Numbers left: [3, 5, 6, 7, 8, 9]
Roll: 4
Game over!

Score for player Math TA: 38 points

$ python solutions.py TA

Numbers left: [1, 2, 3, 4, 5, 6, 7, 8, 9]
Roll: 5
Numbers to eliminate: 5

Numbers left: [1, 2, 3, 4, 6, 7, 8, 9]
Roll: 5
Numbers to eliminate: 4 1

Numbers left: [2, 3, 6, 7, 8, 9]
Roll: 9
Numbers to eliminate: 9

Numbers left: [2, 3, 6, 7, 8]
Roll: 8
Numbers to eliminate: 8

Numbers left: [2, 3, 6, 7]
Roll: 10
Numbers to eliminate: 7 2 1
Invalid input
Numbers to eliminate: 7 3

Numbers left: [2, 6]
Roll: 8
Numbers to eliminate: 2 6

Score for player TA: 0 points
Congratulations!! You shut the box!>>
\end{lstlisting}
\end{problem}

\begin{comment} % Introduce the random module instead. Timing --> Complexity.
\subsection*{The Time and Timeit Modules} % -----------------------------------

The \li{time} module includes functions for dealing with time.
In particular, functions in \li{time} access the computer's system clock.
This is useful for precisely measuring how long it takes for code to run.

The \li{time} module includes a function also called \li{time()} that measures the number of seconds from a fixed starting point, the ``Epoch''.
For most machines, this starting point will be January 1, 1970.

\begin{lstlisting}
>>> import time

# time.time() returns the number of seconds from January 1, 1970 to the
# time of execution. This command gives a new time every time it is run.
>>> time.time()
1436832057.321525
\end{lstlisting}

In order to measure how long it takes to execute some Python code, record the time just before and just after the code in question.
Subtracting the first measurement from the second gives the amount of time in seconds that have passed.

\begin{lstlisting}
# Time how long it takes to go through 10000 iterations using 'range'.
>>> def time_for_loop():
...     start = time.time()         # Clock the starting time.
...     for i in range(10000):      # Perform the operation.
...         pass
...     end = time.time()           # Clock the ending time.
...     return end - start          # Report the difference.
\end{lstlisting}

The standard library also has a module called \li{timeit}.
This library is built specifically to time Python code and has more sophisticated tools than the \li{time} module.
In IPython, \li{timeit} can be used like a built-in function any time with the \li{\%timeit} command.

\begin{lstlisting}
# Time how long it takes to go through 10000 iterations using 'xrange'.
In [0]: %timeit for i in xrange(10000): pass 
1000 loops, best of 3: 303 Âµs per loop
\end{lstlisting}
\end{comment}

\begin{comment} % Old Problem 4 --> Complexity perhaps
\begin{problem} % Problem: put it all together.
Download \texttt{matrix\_multiply.py} and \texttt{matrices.npz}.
The Python file \texttt{matrix\_multiply.py} is a module that has three functions for multiplying two matrices together, called \li{method1()}, \li{method2()}, and \li{method3()}.
It also has a \li{load\_matrices()} function that returns two matrices from \texttt{matrices.npz}.

Modify your solutions file so that when it is run from a Python interpreter (but not when it is imported), the following is executed:
\begin{enumerate}
\item If no command line arguments are given, print ``No Input."
\item If anything other than ``matrices.npz'' is given, print ``Incorrect Input."
\item If ``matrices.npz'' is given as a command line argument, load two matrices from \texttt{matrices.npz}. Time (separately) how long each method takes to multiply the two matrices together, then print the results.

(Hint: Read the code in \texttt{matrix\_multiply.py}, especially the function docstrings, to determine how to use each function.)
\end{enumerate}
\end{problem}
\end{comment}

\newpage

\section*{Additional Material} % ==============================================

\subsection*{More Built-in Functions} % ---------------------------------------

Experiment with the following built-in functions:

\begin{table}[H]
\begin{tabular}{r|l}
Function & Description \\ \hline
\li{all()} & Return \li{True} if \li{bool(entry)} evaluates to \li{True} for \emph{every} entry in \\&the input iterable.\\
\li{any()} & Return \li{True} if \li{bool(entry)} evaluates to \li{True} for \emph{any} entry in the\\&input iterable.\\
\li{bool()} & Evaluate a single input object as \li{True} or \li{False}.\\
\li{eval()} & Execute a string as Python code and return the output.\\
% \li{hash()} & \\
% TODO: include raw_input() in the sys module section.
\li{raw_input()} & Prompt the user for input (as a string).\\
\li{input()} & Prompt the user for input and evaluate it (\li{eval(raw_input())}).\\
% TODO: change this to input() for Python 3.
% \li{iter()} & \\
\li{map()} & Apply a function to every item of the input iterable and return \\&a list of the results.\\
\li{reduce()} & Apply a function accepting two arguments cumulatively to the \\&items of the input iterable from left to right (thus reducing it to\\&a single output).
% \li{repr()} &
\end{tabular}
\end{table}

\subsection*{Python Packages} % -----------------------------------------------

Suppose that we have a handmade module like \texttt{calculator.py} that we would like to use, but which is saved in a different directory than our current file.
In order to use the module, we must make the directory where it is located into a Python \emph{package}.
To do this, create a file named \texttt{\_\_init\_\_.py} in the same directory as the module to be imported.
To import the module, we specify the path to the module relative to the current file.

As an example, suppose we are currently working on a Python file called \texttt{Trees.py} in a folder called \texttt{structures}.
The \texttt{structures} folder is contained within the \texttt{projects} folder, which also contains a \texttt{tools} folder where the \texttt{calculator.py} module is stored.
The complete directory might look something like this.

\begin{lstlisting}
<<projects/
    structures/
        LinkedLists.py
        Trees.py
    tools/
        __init__.py
        calculator.py
        abacus.py>>
\end{lstlisting}

To import the \texttt{calculator.py} module to \texttt{Trees.py}, use the following import command in \texttt{Trees.py}:

\begin{lstlisting}
from ..tools import calculator
\end{lstlisting}

This tells the interpreter to go up one level, enter the \texttt{tools/} directory, and then load the \texttt{calculator.py} module.
For more details and examples on this topic, see \url{https://docs.python.org/2/tutorial/modules.html\#packages}.
